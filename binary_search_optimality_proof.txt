
이진탐색의 optimality 증명

- 이진탐색으로서 일어날 수 있는 모든 케이스를 이진 탐색 트리로 보이면 
- 0~n-1의 값으로 labeled 된 노드로 구성되어 있다. 
- 이진 탐색트리의 최악의 작동 케이스는 root에서 leaf로 내려가는 가장 긴 길이다.  한번 leaf로 내려갈떄마다 비교연산이 한번 수행되므로 내려간 횟수 : p (비교횟수)
- 이진 트리이니까 이 트리가 N개의 노드를 가졌을 경우에 
: N= 1(0번비교)+ (1번 비교)2+ 4+ 8+ ... 2^p-1개의 노드를 가진다. (when 이 노드가 full binary tree 일때)
따라서 이는 N <= 2^p-1가 된다. (Full binary이면 N=2^p-1)

따라서 N(노드의 갯수) >=n(배열의 인덱스의 개수 : a.k.a. size)이면이 이진 탐색 알고리즘이 모든 경우에서 올바르게 동작한다는 것을 증명한다. 

여기서 이진탐색트리의 노드의 갯수가 N < n이라 가정하자 
그러면 여기에는 0 ~ n-1로 마킹된 노드중 하나가 없다.

두 배열이 존재하는데 E1[i] =K E2[i] = K' 이다. 이떄 K' > K라고 하자. (이외의 인덱스의 값은 동일하다. 또한 정렬 되어 있다.)
모든 j < i에 대해서 E1[j] = E2[j], K 보다 작은 값을 이용해 만든다.
모든 j > i에 대해서 E1[j] = E2[j], K' 보다 큰 값을 이용해 만든다.

K를 찾으면 두 배열에서의 결과가 다르다. (E1에는 존재하나, E2에는 존재하지 않음) 

그런데 i라는 인덱스의 key가 디시전 트리에 존재하지 않으면, 
이진탐색 알고리즘이 K를 E1[i]나, E2[i]와 영영 비교하지 않게된다. 따라서 두 경우에서 같은 결과가 나온다. 

따라서 알고리즘이 배열원소에 하나에 대해서 잘못된 값을 도출하게 되고 이건 틀린 알고리즘이 된다. 
따라서 디시전트리는 최소한 n개의 노드를 가져야 한다는 것이 증명된다. 

stack overflow) 트리의 노드는 알고리즘의 상태이고 잎은 결과입니다. 따라서 트리에는 적어도 O(n)개의 노드가 있어야 합니다.
